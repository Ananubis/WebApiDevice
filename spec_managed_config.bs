<pre class='metadata'>
Title: Managed Configuration API
Shortname: managed-configuration
Level: 1
Editor: Anatoliy Potapchuk (Google) apotapchuk@chromium.org
Status: w3c/WD
Issue Tracking: Github https://github.com/WICG/WebApiDevice/issues
URL: http://example.com/url-this-spec-will-live-at
Abstract: This document defines a web platform API that enables developers to access administrator-set configuration on managed devices. Such API invaluable for such use cases as digital signage and device-centric personalization.
TR: 
</pre>

<pre class=link-defaults>
spec:html; type:interface; text:Navigator
</pre>

<pre class="anchors">

</pre>

# Model # {#model}

## Managed devices ## {#managed-devices}

The API is presumed to be used on devices, which are not fully controlled by the end user, but rather by an external entity, the device administrator. Device administrators are given the power to fully control the managed device.

## Managed configuration ## {#managed-configuration}

For the purposes of this specification the device administrator can control a list of managed web applications. Each entry in this list can have a set JSON configuration, which is accessible by the documents hosted at the origin of the web application.

Note that this does not apply to anonymous contexts, where the observed state is indistinguishable from a non-managed one.

## <dfn dfn>Data model</dfn> ## {#data-model-section}

We can assume without loss of generality that managed configuration is stored in a two-level key-value store. The first level of this store corresponds to configured origins, while the second corresponds to per-origin configuration string keys.
## Data integrity verification ## {#data-integrity-verification}

There is no managed configuration verification mechanism defined in the specification, which implies that the website should assume that the configuration could be tampered with, stolen or be replayed on a non-managed device. 

Alternative security measures should be put in place by the website itself.

# Extensions to the {{Navigator}} interface # {#navigator-extensions}

<xmp class="idl">
[
  SecureContext
] partial interface Navigator {
  [SecureContext, SameObject]
  readonly attribute NavigatorManagedData managed;
};
</xmp>


{{managed}} attribute
When getting, the managed attribute always returns the same instance of the {{NavigatorManagedData}} object.

# {{NavigatorManagedData}} interface # {#navigatormanageddata-interface}

<xmp class="idl">
[
  SecureContext,
  Exposed=Window
] interface NavigatorManagedData : EventTarget {
  // Managed Configuration API.
  Promise<object> getManagedConfiguration(sequence<DOMString> keys);
  attribute EventHandler onmanagedconfigurationchange;
};
</xmp>

## {{getManagedConfiguration()}} method ## {#getmanagedconfiguration-method}

The {{getManagedConfiguration()}} method steps are:
1. Let |promise| be a new promise.
1. Run the following steps in parallel:
    1. Try requesting managed configuration by sending {{keys}} to the [=data model=].
    1. If the application is not managed, reject |promise| with a {{NotAllowedError}} DOMException.
    1. Create an empty javascript |object|.
    1. For each of the keys that had an associated  configuration in the [=data model=], add an attribute to the |object|.
    1. Resolve |promise| with |object|.
1. Return |promise|.

## {{onmanagedconfigurationchange}} attribute ## {#onmanagedconfigurationchange-attribute}

{{onmanagedconfigurationchange}} is an event handler IDL attribute for the |managedconfigurationchange| event type.

When any of the configuration values under the origin-level key changes for the current origin, |managedconfigurationchange| event is fired with no value associated with it.


# Security considerations # {#security-considerations}

in accordance with the modern security practices, the configuration data is designed to be isolated by origin and available to secure contexts only, thus preventing other websites from accessing it.

# Privacy considerations # {#privacy-considerations}

Using this API, websites will be capable of identifying managed environments among other non-managed ones. However, this is only possible for web applications which are explicitly configured by the device administrator, which is the whole purpose of this API. Administrator consent for this identification is assumed.

The managed configuration is not exposed to users in anonymous contexts and behaves as if the current origin was not managed.

